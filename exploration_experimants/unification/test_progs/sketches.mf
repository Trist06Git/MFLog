//lazy builtin sets that allow choice points with numbers
//less would be a choice point of less(0), less(1), etc..

less(x) = return < x.         => less(x, return) = return < x.
set = less(5).                => set = [4, 3, 2, 1, 0]

add_more(set) =               => add_more(set, return) =
  return = 10 :: 9 :: set.         return = 10 :: 9 :: set.
set = add_more(set).          => set = [10, 9, 4, 3, 2, 1, 0]

//the set variable get shaddowed here
//in reality it would be a different var with subscript
//eg set0, set1, set2
//also consider scope, so set inside add_more body would be set1
//and would not clash with bound return set1



//expanded less(x), on lazy <
less(5, return) = return = 0.
less(5, return) = return = 1.
less(5, return) = return = 2.
less(5, return) = return = 3.
less(5, return) = return = 4.

//the answer set of the choice point of less/2
set = less(5).     => set = [4, 3, 2, 1, 0]

//also implied:
less(5, set0).
add_more(set0, set1).   => set1 = [10, 9, 4, 3, 2, 1, 0]

//as query:
should_fail(x) =
  x = 5,
  less(5, 10).

thing = should_fail(5).  => []? or bot/fail?... fail/bot I think

////
//in Davids cryptic style:
l(x) = r < x.      => l(x, r) = r < x.
s = l(5).                => s = [4, 3, 2, 1, 0]

m(s) =             => m(s, r) =
  r = 10::9::s.         r = 10::9::s.
s = m(s).          => s = [10, 9, 4, 3, 2, 1, 0]



///scraps:
f(x) = x + 1.
res = f(1, 2).     => []? and not fail/bot??... yes I think

///
bot = ⊥
top = ⊤    //impossible to reach??
not_bot = []
contradiction(x) => 2 < 1.  => res = contradiction(_)   => res = ⊥
negate(x) = x = bot.        => res = negate(⊥). => res = []
negate(_) = bot.

should_fail(x) =
  x = 5,
  contradiction(x).

x = should_fail().          => should_fail(x). => whole_expr = ⊥/fail
thing(y) =
  x = should_fail(),        => this evals as bot/fail, so thing(y) evals as bot/fail
  y = x + 1.

wont_fail(x) =              => wont_fail(x) =
  x = 5,                         x = 5,
  negate(contradicion(x)).       res = contradiction(x),
                                 negate(res).
x = wont_fail().            => x = 5.


//avoiding infinite recursion on explication
menu(quit, state) =
  quit = input(),
  state = do_stuff(state),
  render(state),
  check_quit(quit),
  menu(quit, state).
//above will inf during pre-proc, maybe count fcalls in explic algo
//and quit and tell user to add signature definition?
//eg:

menu/2.
menu(quit, state) =
  quit = input(),
  check_quit(quit),
  menu(quit, state).

/////all answers vs 1
f(x) = x = 1.
f(x) = x = 2.
f(x) = x = 3.

main(res) =
  res = all f(x).

main(res) =
  res = one f(x).

main(res) =
  res = all f(x)[2].

//the third answer is returned, who is a list, then its "one" first answer
main(res) =
  res = one f(x)[2].

////tuples?
f(x) =
  x = 1,
  return = (1, 2).

g(x) =          => g(x, res) =
  res = f(x).   =>   f(x, r1),
                =>   res = r1,
                =>   res = (a, b),
                =>   a = 1,
                =>   b = 2.

g(x) =          => g(x, r1, r2) =
  res = f(x),   =>   f(x, r0),
  res = (i, j), =>   res = r0,
  h(i, r1),     =>   res = (i, j),
  h(j, r2).     =>   h(i, r1),
                =>   h(j, r2),

simple(x) =     => simple(x),
  x = (1,2).    =>   x = (a,b),
                =>   a = 1,
                =>   b = 2.
////binding the vars of a tuple should be
//the other way around, that way a sane
//fully bound tuple is returned, without
//anonymous vars
simple(x) =     => simple(x),
  x = (1,2).    =>   x = (1,2),
                =>   t_0_0 = 1,
                =>   t_0_1 = 2.

////list syntax
app(x, l) =        => app(1, 2::3::[], return) =
  return = x::l.   =>   return = 1::2::3::[].
 
app(x, l) =        => app(1, 2;;3;;[], return) =
  return = x;;l.   =>   return = 1;;2;;3;;[].

cat(l1, l2) =      => cat(1;;2, 3;;4, return) =
  return = l1::l2. =>   return = 1;;2::3;;4.
                     => return = [1,2]::[3,4].

app(x, l) =
  return = x :: l.
cat(l1, l2) =
  return = l1++l2.
cat([1;2], [3;4], [1;2;3;4]).